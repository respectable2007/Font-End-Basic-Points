<!DOCTYPE html>
<html>
  <head>
      <title>h5</title>
  </head>
  <body>
      <input type='text' list="5" autocomplete="on">
      <datalist id='5'>
          <option>GOOD Morning</option>
          <option>GOOD Noon</option>
          <option>3</option>
          <option>GOOD After</option>
      </datalist>
      <input type='text'>
      <input type='date'>
      <input type='time'>
      <input type='datetime'>
      <input type='month'>
      <input type='week'>
      <input type='color'>
	  <div>
	    <input type='file' id='file' multiple>
		<p id='con'></p>
	  </div>
	  <script type='text/javascript' src='spark-md5.min.js'></script>
      <script type='text/javascript'>
        var vue = {},
		config = {
		  performance:false
		};
		/*在访问器属性getter内声明的变量均为只读，
		  若访问器getter内返回的对象（configX）在内部声明，
		  则configX的属性均为只读；
		  若访问器getter内返回的对象（config）在外部已声明，
		  则可通过定义了getter的属性（configM）读取和写入config属性
		*/
        Object.defineProperty(vue, 'configM', {
          get: function() {
            //return config;
			var configX = {
			  performance: false
			}
			return configX;
          }
        })
		console.log(vue.config);
		vue.config = {};
		console.log(vue.config);
		vue.config.performance = true;
		console.log(vue.config.performance);
		
		function Vue() {
		}
		Vue.options = {child:1}
		Vue.prototype.option = function() {
		  console.log('instance');
		}
		var vue = new Vue();
		/*vue没有继承Vue的静态属性，只是继承了实例属性和方法；
		  静态属性和方法只能通过构造函数调用和访问
		*/
		console.log(vue.option)
		
		let input = document.getElementById('file'),
		    p = document.getElementById('con');
		input.addEventListener('change', function(e){
		  let file = e.target.files[0],
		      slice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice,
		      size = file.size,
			  type = file.type,
			  chunkSize = 102400,//100KB
			  chunks = Math.ceil(size/chunkSize),
			  currentChunk = 0,
			  md5 = new SparkMD5(),
			  blob,
			  reader = new FileReader();
		  p.innerHTML = '长度：' + size + '；文件类型：' + type;
		  function loadText(){
		    var start = currentChunk * chunkSize,
			    end = ((currentChunk * chunkSize + chunkSize) < size) ? start + chunkSize : size;
			//文件拆分
		    blob = slice.call(file, start, end);
			reader.readAsText(blob);
		  }
		  reader.onerror = function(){
			console.log('read error');
		  }
		  reader.onload = function() {
			md5.append(reader.result);
			currentChunk++;
			if(currentChunk < chunks){
			  loadText();
			} else {
			  console.log('文件特征',md5.end());
			}
		  }
		  loadText();
		})
      </script>
  </body>
</html>